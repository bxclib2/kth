\documentclass[11pt]{exam}
\usepackage{listings}
\usepackage[swedish]{babel}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc} 
\usepackage{algorithm}
\usepackage{algorithmic}
%
%  Created by hwaxxer on 2009-04-26.
%  Copyright (c) 2009 __MyCompanyName__. All rights reserved.
%
%

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage{subfigure}
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

%
%  Update these values for running headers
%
\firstpageheader{\bf\Large }{\bf\Large \begin{center}Algoritmer, datastrukturer och komplexitet\end{center}
Mästarprov 2}{\bf\Large}
\runningheader{Martin Hwasser}{}{Mästarprov 2}
\addpoints
\vspace{2 cm} 

\begin{document}

% setup standard options for the including code fragments
\lstset{language=Python,numbers=left}
\hbox to \textwidth{Namn:\enspace\hrulefill} 
\vspace{2 cm} 

% Questions start here:
\begin{questions}

\question \textbf{Hållbart kommunikationsnät}

Som indata till det generella handelsresandeproblemet, TSP, får vi en fullständig graf G med positiva heltalskantvikter och ett positivt heltal, mål M. Frågan lyder: Finns det en tur runt hörnen som passerar varje hörn i G exakt en gång och som har en sammanlagd kantviktssumma på högst M? 

Som indata till Hållbart kommunikationsnät får vi en n x n matris K, en array A som anger antalet kablar som ska gå från varje nod, samt ett mål M - alltså det kabelantal som inte får överstigas. Betrakta följande reduktion:

\begin{algorithm}
	\caption{TSP(G, M)}
	\begin{algorithmic}
		\FORALL{hörn $u,v$ i $G$}
			\STATE $K[u][v] \leftarrow kantvikt(u,v)$ \COMMENT{Vi fyller en matris med kantvikter}
		\ENDFOR
		\FORALL{hörn $h$ i $G$} 
			\STATE $A[h] \leftarrow 2$ \COMMENT{Vi får inte passera ett hörn mer än en gång}
		\ENDFOR
		\STATE return HållbartKommunikationsnät(K, A, M)
	\end{algorithmic}
\end{algorithm}

Vi representerar alltså grafen $G$ som en symmetrisk matris, $K$, där $K[u][v]$ representerar kantvikterna, dvs kostnaden för dra en kabel mellan hörnen $u$ och $v$. Vi behöver bara 2 kanter per hörn, eftersom vi ska passera varje hörn en gång. Vi behöver alltså en kant för att komma till hörnet, och en för att besöka ett annat hörn. $A[h]$ anger hörn $h$:s valens, dvs antalet kablar som ska gå till hörn $h$. Målet $M$ är detsamma som för handelsresandeproblemet TSP.

Om det inte finns en hamiltoncykel, dvs att varje stad (hörn) besök en gång, vars totala längd är högst $M$, så är det inte heller möjligt att bygga ett hållbart kommunikationsnät, vilket är trivialt att inse.

För att visa att problemet ligger i NP behöver vi visa att en lösning till problemets går att verifiera i polynomiell tid. För att verifiera en lösning till Hållbart kommunikationsnät så behöver vi bekräfta att det i matrisen $K$ ligger rätt antal kablar mellan alla noder, såsom specificerat av arrayen $A$, summera antalet kablar och kolla att antalet inte är större än målet $M$. Detta tar linjär tid i grafens storlek. Verifieringen tar alltså polynomiell tid och problemet ligger således i NP.

Problemet är NP-svårt, ty vi har reducerat det NP-fullständiga handelsresandeproblemet. Eftersom det ligger i NP och är NP-svårt är det också NP-fullständigt.
\newpage

\question \textbf{Energisnålt garage för tåg}

Beslutsproblemet: Kan vi få plats med tågen i ett garage med sidan K?

Som indata till Lådpackningsproblemet får vi $n$ prylar med rationella vikter $w_1, ..., w_n$ mellan 0 och 1, och frågan lyder: Vilket är det minsta antal lådor som behövs för att förvara alla $n$ prylar utan att någon låda innehåller mer än 1 kg?

Som indata till Energisnålt garage för tåg har vi en array $A$ med $n$ stycken positiva heltal $t_1, ..., t_n$ där $t_i$ anger längden på tågsätt nr $i$, samt ett mål $K$. Frågan lyder: Går det att avgöra ifall det finns något sätt att parkera tågsätten i ett garage med sidan $K$?

\begin{algorithm}
	\caption{Lådpackning($w_1, .., w_n, K$)}
	\begin{algorithmic}
		\STATE $faktor \leftarrow K$
		\FOR{$i \leftarrow 1$ to $n$}
			\STATE $faktor \leftarrow faktor * $nämnare$(w_i)$ \COMMENT{Vi vill bara ha heltal som indata}
		\ENDFOR
		\FOR{$i \leftarrow 1$ to $n$}
			\STATE $A[i] = w_i * faktor$ \COMMENT{Skapa array med tåg från vikterna}
		\ENDFOR
		\STATE $t \leftarrow$ tåg med längd $faktor$ 
		\FOR[Fyll ut överflödiga spår]{$i \leftarrow K + 1$ to $faktor$}
			\STATE $A[i] \leftarrow t$
		\ENDFOR
		\STATE return EnergisnåltGarage(A, faktor)
	\end{algorithmic}
\end{algorithm}

Vi tar indata från lådpackningsproblemet, och använder prylarna som tåg och lådorna som spår. Vi förlänger varje tåg genom att multiplicera med produkten av alla nämnare eftersom vi behöver heltal som indata till Energisnålt Garage. Eftersom garaget måste kvadratiskt multiplicerar vi också med antalet lådor, $K$. Vi kallar produkten av alla nämnare * $K$ för $faktor$.

Problemet nu är att tågen är för långa och får alltså kanske inte plats på spåren. Vi ökar därför sidan på garaget till $faktor$. Nu har vi alltså för många spår att ställa tågen på, så vi lägger till $faktor - (K + 1)$ stycken tåg av längd $faktor$, dvs vi fyller igen överflödiga spår. Detta lämnar oss med $K$ stycken spår av längd $faktor$ där tågen ska få plats. Istället för $K$ stycken lådor som rymmer $1$ kg med vikterna $w_1, ..., w_n$ har vi alltså $K$ stycken spår som rymmer $faktor$ långa tåg med tågen $t_1 * faktor, ..., t_n * faktor$, och på så sätt har vi behållit proportionerna mellan alla värden.

Problemet ligger i NP eftersom vi lätt verifierar lösningen i polynomiell tid. Problemet är NP-svårt eftersom vi har reducerat ett NP-fullständigt problem. Alltså är problemet NP-fullständigt.

\newpage
\question \textbf{Konstruktion av parkering i energisnålt tåggarage}

För att ta reda på den minsta garagesidan $K$, så kan vi börja med att ansätta $K = 1$, och sedan anropa beslutsproblemet och öka $K$ med 1 varje gång vi får en nej-instans. När vi således får en ja-instans vet vi att vi kan bygga ett garage med sidan $K$ så att alla tåg $t_1, ..., t_n$ får plats.

		
Problemet är sedan att beskriva vilka tågsätt som ska parkera på samma spår, och detta kan vi göra genom att ''sätta ihop'' två tåg för att på så vis se om de kan stå på samma spår. Om vi fortfarande får en ja-instans med samma mål $K$ så vet vi att de kan stå parkerade på samma spår.

\begin{algorithm}
	\caption{OptimalParkering(T)}
	\begin{algorithmic}
		\STATE $M \leftarrow 1$
		\WHILE[Kan vi få plats med alla tåg med garagesidan M?]{Beslut(T, M) != true}
			\STATE $M \leftarrow M + 1$
		\ENDWHILE
		\STATE $s \leftarrow 1$ \COMMENT{Spår $s$}
		\FORALL[För alla kvarvarande tåg i $T$]{$t$ in $T$}
			\STATE Låt $L$ vara en tom lista
			\STATE Lägg till $t$ till $L$
			\STATE $i \leftarrow 2$
			\WHILE{$i < T$}
				\STATE $X = t + t_i$ \COMMENT{Sätt ihop två tåg}
				\STATE $T = T + \{X\} - \{t\} - \{t_i\}$ \COMMENT{Ta bort tågen som vi slagit ihop från $T$ och lägg till $X$}
				\IF[Är detta tågsätt en möjlighet i en optimal lösning?]{$Beslut(T, M)$}
					\STATE Lägg till $t_i$ till $L$
					\STATE $t \leftarrow X$ \COMMENT{Vi ökar tågstorleken till X}
				\ELSE
					\STATE $T = T - \{X\} + \{t\} + \{t_i\}$ \COMMENT{De kan inte stå på samma spår}
				\ENDIF
				\STATE $i \leftarrow i+1$
			\ENDWHILE
			\STATE $P[s] \leftarrow L$ \COMMENT{Lägg till alla tåg som finns i $L$ till spår $s$}
			\STATE $s \leftarrow s + 1$ \COMMENT{Det får inte plats några andra spår på $s$}
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

Vad som händer är att vi slår ihop tåg, och undersöker om det finns nåt sätt att parkera med de ihopparade tågen. Om det finns betyder det att det finns en optimal lösning där de ihopslagna tågen befinner sig på samma spår. Om det inte finns betyder det att tågen inte kan vara på samma spår i en optimal lösning. 

Vi vet att algoritmen fungerar eftersom längden av två tåg parkerade bredvid varandra är lika lång som två ihopslagna tåg. 
För varje tåg $t$ behöver vi gå igenom alla kvarvarande tåg och undersöka om de kan stå på samma spår, så vi får tidskomplexiteten $O(n^2 * B(n))$

\end{questions}

\end{document}

